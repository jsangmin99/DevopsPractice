# 쉘스크립트
- 일반적인 언어는 컴파일 과정이 필요하지만
- 이터프리터 언어이다. 컴파일을 거치지 않고 바로 실행
- .`sh` 확장자를 가진다.
- 시작할때는 `#!` (셔뱅) 로 시작한다.
	- `#!/bin/bash`
	- `#!/usr/bin/python3`
	- `#!/usr/bin/ruby`
- 실행방법
	- `bash 파일이름`
	- 실행권한을 준뒤 `./파일이름`

#### 변수 할당
- 변수 내부에 공백이 있을 경우 "" 또는 '' 를 사용해야한다.
- `$` 표시하여 변수를 사용한다. 

```bash
#!/bin/bash
name="sangmin"
age="27"

echo "이름 : $name"
echo "나이 : $age"

```
#### 인수
```bash
#!/bin/bash
echo "Script name: $0"
echo "First argument: $1"
echo "2 arg: $2"
echo "number of arg: $#"
echo "First argument: $1"

for arg in "$@"
do
        echo "arg $arg"
done
```

![[Pasted image 20250625123700.png]]


#### 정상적으로 종료되었는지 확인
- exit 0 : 정상적으로 종료
- exit 1 : 비정상적 종료
```bash
#!/bin/bash

if [ $# -eq 0 ]; then
        echo "No arg"
        exit 1
fi

echo "ok"
exit 0
```

- ./ exitcode.sh  입력시 변수를 할당하지 않아 `No arg`   `exit1` 비정상적 종료
- ./ exitcode.sh AAA 입력시 변수를 할당하였기 때문에 정상종료

- export 사용시 다른 쉘에서 사용할수있다. (전역변수 개념)
	![[Pasted image 20250625112547.png]]


#### 입력받는 방법
- `read 를 사용`
```bash
#!/bin/bash
echo " what is your name"
read name
# 인수를 두개받을 경우
# read first last
echo "hello. $name!!"
```

![[Pasted image 20250625132443.png]]

- V2
``` bash
#!/bin/bash
echo " what is fist name"
read first

echo " what is your last name"
read last

echo "first name: $first"
echo "last name: $last"
``` 
![[Pasted image 20250625133116.png]]


#### IF 문
``` bash
#!/bin/bash
str1="hello"
str2="hello"

if [ "$str1" == "$str2" ]; then
        echo "equal"
else
        echo "not equal"
fi

```

#### For 문
``` bash
#!/bin/bash

for i in 1 2 3 4 5; do
        echo "number: $i"
done

```

#### 기호
- 옛날방식
	- -eq -ne -gt -lt
- 최신방식
	- == =/ > < 


# 프로세스
- 프로세스 : 실행중인 프로그램
- 프로세서 : 프로그램을 작동하게하는 장비 (CPU)
- PID : 운영체제에서 실행중인 각 프로세스를 구별하기 위해 부여하는 고유한 번호

리눅스가 시작되면 sytemd 라는 프로세스가 시작된다. 이는 pid 1 번을 가지게 된다.
systemd는 부모프로세스가되어 자식프로세스들을 생성한다.
이는 계층적인 구조를 가지게된다.
프로세스가 다른프로세스를 생성하는것을 자식프로세스라고 한다.

터미널에서 명령어를 입력할경우
- **터미널의 쉘이 부모 프로세스가 된다**
    - 터미널에서 사용자가 명령어를 입력하면, 그 명령어를 처리하는 쉘(shell) 프로세스가 부모 프로세스 역할을 한다.
- **부모 프로세스가 자신을 복제해서 자식 프로세스를 만든다**
    - 부모 프로세스(쉘)는 `fork()` 시스템 호출을 통해 자기 복제본인 자식 프로세스를 생성한다.
- **자식 프로세스는 부모 프로세스와 동일한 자원과 정보를 복제받는다**
    - 자식 프로세스는 부모의 메모리, 변수, 열린 파일 디스크립터 등 거의 모든 상태를 그대로 복사받아 시작한다.
- **자식 프로세스는 자신의 작업 공간에 실행할 명령어를 덮어씌운다**
    - 자식 프로세스는 `exec()` 계열 시스템 호출로 자신이 복제한 부모 프로세스의 메모리 공간에, 실제 실행할 명령어(프로그램)로 덮어씌운다.
    - 이렇게 해서 자식 프로세스는 입력한 명령어를 수행하는 실행 프로세스로 변신한다.
- **부모 프로세스는 그동안 자식 프로세스가 끝나길 대기한다**
    - 부모 프로세스는 `wait()` 호출을 통해 자식 프로세스가 작업을 마치고 종료할 때까지 기다린다.
- **자식 프로세스가 명령어를 실행하고 종료한다**
    - 자식 프로세스가 명령어 수행을 마치면 종료 상태를 부모 프로세스에게 알려준다.
- **부모 프로세스는 다시 다음 명령어 입력을 기다린다**
    - 자식 프로세스가 종료된 후, 부모 프로세스는 제어권을 다시 사용자에게 넘기고 새로운 명령어를 대기한다.


#### 프로세스를 확인하는 명령어
- `ps`
	-  -a : 모든 프로세스
	- -u : 유저와 관련된정보를 보여줌
	- -x : 로그인 상태에 있는 동안 아직 완료되지 않은 프로세스를 출력.
- pstree
	- 프로세그의 구조를 쉽게보여준다.
		![[Pasted image 20250625143252.png]]
	-  -p : pid 정보도 같이나옴
	-  -u : user 정보도 같이 나옴

### TOP 명령어
- 시스템의 프로세스를 실시간으로 확인할수있는 강력한 도구 이다.
- 메모리 cpu 등의 정보를 실시간으로 보여줌
- TOP 실행후 
	- P 누르면 CPU 순
	- M 누르면 메모리순
	- T 누르면 시간순
	- h 누르면 help

### pgrep 
- ps 와 grep을 합친 명령어로 원하는 프로세스를 출력하는것
	![[Pasted image 20250625144302.png]]

## 상태
- Running
	- CPU를 할당받아 실행 중인 상태
- Created (생성)
	- 사용자가 요청한 작업이 커널에 등록되고 PCB가 만들어져 프로세스가 만들어진 상태.
	- Created -> Ready : 메모리 공간을 검사하여 충분한 공간이 있으면 메모리를 할당하고 준비 상태로 바꾼다.
	- Created -> Suspended Ready : 공간이 없으면 메모리를 할당하지 않고 보류 준비로 바꾼다.
- Ready (준비)
	- CPU를 할당 받기 위해 기다리고 있는 상태. CPU만 주어지면 바로 실행할 준비가 된 상태이다.
- sleap = 인터럽트 가능 인터럽트 불가능
- T 프로세스가 일시 중단된 상태
- Z 좀비프로세스 : 
	- 자식 프로세스가 끝났는데 부모프로세스가 자식 프로세스를 회수하지 못한 상태
	- 실질적으로 자원을 별로 사용하지 않지만 pid 자원을 낭비하게 됨
- 고아 프로세스 프로세스가 중단되어 부모가 없어짐
	-  고아 프로세스가 생기면 sytemd 에서 거둬들여 관리함

#### 데몬프로세스
- 시스템을 원활하게 작동하도록함
- 사용자와 서로 상호작용하지 않는다
- 주로 시스템 서비스 제공하는 역할을 한다.
- 백그라운드에서 실행한다.

### 제어 시그널
- `kill -9`
- 시그널은 프로세스에게 보내지는 일종의 메세지
- 신호는 숫자로 식별되며 동작이 정해져 있다.
- 1  hangup 터미널이 끊겼을때 나타난다 데몬이 이를 확인한다
- 2 해당 프로세스에 중단요청 시그널이 전달된다.
- 3 종료시그널 2번 보다 강력하게 종료를 요청한다.
- 9 강제종료 시그널 프로세스가 즉시종료된다.
- 15 종료시그널 프로세스에게 정상적으로 종료를 요청
- 19 중지 시그널 프로세스가 일시 중지 요청을한다.

who 입력시 뒤에 있는 ip는 원격접속 위치를 의미함
tty : 물리적으로 연결되어있는 터미널
pts : 원격터미널을 의미함
tty : 가상 콘솔


# 아카이브
## 아카이브 ⭐⭐⭐
- 여러개의 파일이나 디렉토리들을 하나의 파일로 묶는것을 말한다.
- 용량이 줄어들진 않는다.
- 주로 `tar` 라는 도구를 쓴다.
- tar : 
	- 확장자 : .tar
	- 특징 : 압축하지 않음
- 옵션
	- f : 대상 tar 아카이브 지정(기본옵션)
	- c : 생성
	- x
	- v
- tar 로 묶인 파일을 풀때 기존 있는 파일과 tar안에 있는 파일이름이 같을경우 tar내부에있는 파일로 덮어씌워짐 
	- k옵션을 사용하여 이름이 동일할경우 경고 메시지를 보냄
- tar -xvf docs2.tar -C /tmp/
	- C 옵션을 사용하여 원하는 위치에 풀수있다.
## 압축
- 파일의 크기를 줄이는 기술
- `gzip` , `gizp`, `bzip2`, `xz` 다양한 압축도구가있다.

- gzip
	- 확장자 : .gz
	- 특징: 일반적으로 사용, 압축속도가 빠름 , 많이넣을순 없다.
	- 
- bzip2
	- 확장자 : .bz2
	- 특징 : 압축률은 높으나 속도가 느리다.
- xz
	- 확장자 : .xz
	- 특징 : 가장 높은 압축률, 속도가 느림
- zip
	- 확장자 : .zip
	- 특징 윈도우와 호환성이 좋음


---


**
문제 1
1. myscript.sh 라는 이름의 셸 스크립트 파일을 생성하세요.  
    해당 스크립트는 다음 기능을 수행해야 합니다:

2. 셔뱅 라인 추가
    
3. "Hello, Shell Programming!"이라는 메시지 출력
    
4. 현재 날짜와 시간 출력
    
5. 현재 사용자 출력
    
6. 스크립트에 실행 권한을 부여하세요.
    
7. 스크립트를 실행하여 결과를 확인하세요.
    


  문제 2
1. param.sh라는 이름의 셸 스크립트 파일을 생성하세요.  
    해당 스크립트는 다음 기능을 수행해야 합니다:
    
2. 스크립트 이름 출력
    
3. 전달된 매개 변수의 개수 출력
    
4. 두 번째 매개 변수 출력
    
5. 모든 매개 변수 출력
    
6. 스크립트에 실행 권한을 부여하세요.
    
7. 적절한 인수를 넣어서 결과를 확인하세요.  
      
    

문제 3
1. 디렉토리에 input.sh라는 이름의 셸 스크립트 파일을 생성하세요.  
    해당 스크립트는 다음 기능을 수행해야 합니다:
    
2. 사용자에게 이름을 입력하라는 메시지 표시
    
3. 사용자에게 나이를 입력하라는 메시지 표시
    
4. "안녕하세요, [이름]님! [나이]세이시군요."라는 형식으로 환영 메시지 출력
    
5. 스크립트에 실행 권한을 부여하세요.
    
6. 스크립트를 실행하여 결과를 확인하세요.  
      
문제 4
7. check_file.sh라는 이름의 셸 스크립트 파일을 생성하세요. (도전 문제)  
    해당 스크립트는 다음 기능을 수행해야 합니다:
8. 사용자에게 파일명을 입력받기
    
9. 입력받은 파일이 존재하는지 확인
    
10. 존재한다면, 일반 파일인지 디렉토리인지 구분하여 메시지 출력
    
11. 파일이 존재하지 않는다면, "파일이 존재하지 않습니다." 라고 출력
    
12. 스크립트에 실행 권한을 부여하세요.
    
13. 다음 경우에 대해 스크립트를 테스트하세요:
    
14. /etc/passwd
    
15. /etc
    
16. 존재하지 않는 파일명  

문제 5
 1. functions.sh라는 이름의 셸 스크립트 파일을 생성하세요. (도전 문제)  
    다음 2개의 함수를 포함하는 스크립트를 작성하세요:
    
2. add: 두 숫자를 인수로 받아 합계를 출력하는 함수
    
3. is_even: 숫자를 인수로 받아 짝수인지 여부를 출력하는 함수
    
4. 사용자에게 두 숫자를 입력받기
    
5. add 함수를 호출하여 두 숫자의 합계 출력
    
6. 첫 번째 숫자가 짝수인지 is_even 함수를 호출하여 확인
    
7. 스크립트에 실행 권한을 부여하세요.
    
8. 스크립트를 실행하여 결과를 확인하세요.

문제 6

1. ps 명령어를 사용하여 현재 터미널에서 실행 중인 프로세스만 확인하세요.
    - ps -ef
2. ps 명령어를 사용하여 시스템의 모든 프로세스를 확인하세요.
    - ps -ax
3. ps 명령어를 사용하여 PID가 1인 프로세스의 정보를 확인하세요.
    - ps -p 1
4. ps 명령어를 사용하여 CPU 사용률이 높은 순서대로 프로세스를 정렬하여 상위 5개만 확인하세요.
	- ps axo %cpu,comm --sort=-%cpu | head -n 6
    
5. 프로세스 계층 구조를 확인하세요.
	- pstree
    
6. PID와 함께 프로세스 트리를 확인하세요.
    - pstee -p
7. sshd 프로세스와 그 자식 프로세스만 트리로 확인하세요.
	- pstree | grep sshd
8. 다음 명령을 입력하여 'sleep 300' 명령을 백그라운드로 실행하세요
    - sleep 300&

9. jobs 명령어를 사용하여 현재 백그라운드로 실행 중인 작업 목록을 확인하세요.
    
10. 두 번째 'sleep 600' 명령을 백그라운드로 실행하세요.
    
11. 현재 실행 중인 sleep 프로세스의 PID를 모두 확인하세요.
    
12. kill 명령어를 사용하여 첫 번째 sleep 프로세스를 종료하세요.
    