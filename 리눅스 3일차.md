# 쉘스크립트
- 일반적인 언어는 컴파일 과정이 필요하지만
- 이터프리터 언어이다. 컴파일을 거치지 않고 바로 실행
- .`sh` 확장자를 가진다.
- 시작할때는 `#!` (셔뱅) 로 시작한다.
	- `#!/bin/bash`
	- `#!/usr/bin/python3`
	- `#!/usr/bin/ruby`
- 실행방법
	- `bash 파일이름`
	- 실행권한을 준뒤 `./파일이름`

#### 변수 할당
- 변수 내부에 공백이 있을 경우 "" 또는 '' 를 사용해야한다.
- `$` 표시하여 변수를 사용한다. 

```bash
#!/bin/bash
name="sangmin"
age="27"

echo "이름 : $name"
echo "나이 : $age"

```
#### 인수
```bash
#!/bin/bash
echo "Script name: $0"
echo "First argument: $1"
echo "2 arg: $2"
echo "number of arg: $#"
echo "First argument: $1"

for arg in "$@"
do
        echo "arg $arg"
done
```

![[Pasted image 20250625123700.png]]


#### 정상적으로 종료되었는지 확인
- exit 0 : 정상적으로 종료
- exit 1 : 비정상적 종료
```bash
#!/bin/bash

if [ $# -eq 0 ]; then
        echo "No arg"
        exit 1
fi

echo "ok"
exit 0
```

- ./ exitcode.sh  입력시 변수를 할당하지 않아 `No arg`   `exit1` 비정상적 종료
- ./ exitcode.sh AAA 입력시 변수를 할당하였기 때문에 정상종료

- export 사용시 다른 쉘에서 사용할수있다. (전역변수 개념)
	![[Pasted image 20250625112547.png]]


#### 입력받는 방법
- `read 를 사용`
```bash
#!/bin/bash
echo " what is your name"
read name
# 인수를 두개받을 경우
# read first last
echo "hello. $name!!"
```

![[Pasted image 20250625132443.png]]

- V2
``` bash
#!/bin/bash
echo " what is fist name"
read first

echo " what is your last name"
read last

echo "first name: $first"
echo "last name: $last"
``` 
![[Pasted image 20250625133116.png]]


#### IF 문
``` bash
#!/bin/bash
str1="hello"
str2="hello"

if [ "$str1" == "$str2" ]; then
        echo "equal"
else
        echo "not equal"
fi

```

#### For 문
``` bash
#!/bin/bash

for i in 1 2 3 4 5; do
        echo "number: $i"
done

```

#### 기호
- 옛날방식
	- -eq -ne -gt -lt
- 최신방식
	- == =/ > < 


# 프로세스
- 프로세스 : 실행중인 프로그램
- 프로세서 : 프로그램을 작동하게하는 장비 (CPU)
- PID : 운영체제에서 실행중인 각 프로세스를 구별하기 위해 부여하는 고유한 번호

리눅스가 시작되면 sytemd 라는 프로세스가 시작된다. 이는 pid 1 번을 가지게 된다.
systemd는 부모프로세스가되어 자식프로세스들을 생성한다.
이는 계층적인 구조를 가지게된다.
프로세스가 다른프로세스를 생성하는것을 자식프로세스라고 한다.

터미널에서 명령어를 입력할경우
- **터미널의 쉘이 부모 프로세스가 된다**
    - 터미널에서 사용자가 명령어를 입력하면, 그 명령어를 처리하는 쉘(shell) 프로세스가 부모 프로세스 역할을 한다.
- **부모 프로세스가 자신을 복제해서 자식 프로세스를 만든다**
    - 부모 프로세스(쉘)는 `fork()` 시스템 호출을 통해 자기 복제본인 자식 프로세스를 생성한다.
- **자식 프로세스는 부모 프로세스와 동일한 자원과 정보를 복제받는다**
    - 자식 프로세스는 부모의 메모리, 변수, 열린 파일 디스크립터 등 거의 모든 상태를 그대로 복사받아 시작한다.
- **자식 프로세스는 자신의 작업 공간에 실행할 명령어를 덮어씌운다**
    - 자식 프로세스는 `exec()` 계열 시스템 호출로 자신이 복제한 부모 프로세스의 메모리 공간에, 실제 실행할 명령어(프로그램)로 덮어씌운다.
    - 이렇게 해서 자식 프로세스는 입력한 명령어를 수행하는 실행 프로세스로 변신한다.
- **부모 프로세스는 그동안 자식 프로세스가 끝나길 대기한다**
    - 부모 프로세스는 `wait()` 호출을 통해 자식 프로세스가 작업을 마치고 종료할 때까지 기다린다.
- **자식 프로세스가 명령어를 실행하고 종료한다**
    - 자식 프로세스가 명령어 수행을 마치면 종료 상태를 부모 프로세스에게 알려준다.
- **부모 프로세스는 다시 다음 명령어 입력을 기다린다**
    - 자식 프로세스가 종료된 후, 부모 프로세스는 제어권을 다시 사용자에게 넘기고 새로운 명령어를 대기한다.


#### 프로세스를 확인하는 명령어
- `ps`
	-  -a : 모든 프로세스
	- -u : 유저와 관련된정보를 보여줌
	- -x : 로그인 상태에 있는 동안 아직 완료되지 않은 프로세스를 출력.
- pstree
	- 프로세그의 구조를 쉽게보여준다.
		![[Pasted image 20250625143252.png]]
	-  -p : pid 정보도 같이나옴
	-  -u : user 정보도 같이 나옴

### TOP 명령어
- 시스템의 프로세스를 실시간으로 확인할수있는 강력한 도구 이다.
- 메모리 cpu 등의 정보를 실시간으로 보여줌
- TOP 실행후 
	- P 누르면 CPU 순
	- M 누르면 메모리순
	- T 누르면 시간순
	- h 누르면 help

### pgrep 
- ps 와 grep을 합친 명령어로 원하는 프로세스를 출력하는것
	![[Pasted image 20250625144302.png]]

## 상태
- Running
	- CPU를 할당받아 실행 중인 상태
- Created (생성)
	- 사용자가 요청한 작업이 커널에 등록되고 PCB가 만들어져 프로세스가 만들어진 상태.
	- Created -> Ready : 메모리 공간을 검사하여 충분한 공간이 있으면 메모리를 할당하고 준비 상태로 바꾼다.
	- Created -> Suspended Ready : 공간이 없으면 메모리를 할당하지 않고 보류 준비로 바꾼다.
- Ready (준비)
	- CPU를 할당 받기 위해 기다리고 있는 상태. CPU만 주어지면 바로 실행할 준비가 된 상태이다.
- sleap = 인터럽트 가능 인터럽트 불가능
- T 프로세스가 일시 중단된 상태
- Z 좀비프로세스 : 
	- 자식 프로세스가 끝났는데 부모프로세스가 자식 프로세스를 회수하지 못한 상태
	- 실질적으로 자원을 별로 사용하지 않지만 pid 자원을 낭비하게 됨
- 고아 프로세스 프로세스가 중단되어 부모가 없어짐
	-  고아 프로세스가 생기면 sytemd 에서 거둬들여 관리함

#### 데몬프로세스
- 시스템을 원활하게 작동하도록함
- 사용자와 서로 상호작용하지 않는다
- 주로 시스템 서비스 제공하는 역할을 한다.
- 백그라운드에서 실행한다.

### 제어 시그널
- `kill -9`
- 시그널은 프로세스에게 보내지는 일종의 메세지
- 신호는 숫자로 식별되며 동작이 정해져 있다.
- 1  hangup 터미널이 끊겼을때 나타난다 데몬이 이를 확인한다
- 2 해당 프로세스에 중단요청 시그널이 전달된다.
- 3 종료시그널 2번 보다 강력하게 종료를 요청한다.
- 9 강제종료 시그널 프로세스가 즉시종료된다.
- 15 종료시그널 프로세스에게 정상적으로 종료를 요청
- 19 중지 시그널 프로세스가 일시 중지 요청을한다.

who 입력시 뒤에 있는 ip는 원격접속 위치를 의미함
tty : 물리적으로 연결되어있는 터미널
pts : 원격터미널을 의미함
tty : 가상 콘솔


# 아카이브
## 아카이브 ⭐⭐⭐
- 여러개의 파일이나 디렉토리들을 하나의 파일로 묶는것을 말한다.
- 용량이 줄어들진 않는다.
- 주로 `tar` 라는 도구를 쓴다.
- tar : 
	- 확장자 : .tar
	- 특징 : 압축하지 않음
- 옵션
	- f : 대상 tar 아카이브 지정(기본옵션)
	- c : 생성
	- x
	- v
- tar 로 묶인 파일을 풀때 기존 있는 파일과 tar안에 있는 파일이름이 같을경우 tar내부에있는 파일로 덮어씌워짐 
	- k옵션을 사용하여 이름이 동일할경우 경고 메시지를 보냄
- tar -xvf docs2.tar -C /tmp/
	- C 옵션을 사용하여 원하는 위치에 풀수있다.
## 압축
- 파일의 크기를 줄이는 기술
- `gzip` , `gizp`, `bzip2`, `xz` 다양한 압축도구가있다.

- gzip
	- 확장자 : .gz
	- 특징: 일반적으로 사용, 압축속도가 빠름 , 많이넣을순 없다.
	- 
- bzip2
	- 확장자 : .bz2
	- 특징 : 압축률은 높으나 속도가 느리다.
- xz
	- 확장자 : .xz
	- 특징 : 가장 높은 압축률, 속도가 느림
- zip
	- 확장자 : .zip
	- 특징 윈도우와 호환성이 좋음
